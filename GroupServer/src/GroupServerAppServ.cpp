/* Generated by Together */

#include <iostream>
#include "GroupServerApp.h"
#include "GameCommon.h"
#include "CommFunc.h"
#include "DBConnect.h"
#include "Team.h"
#include "GuildBankMsg.h"

// 计时退出机制宏切换
//#define CHAEXIT_ONTIME


bool GroupServerApp::OnConnect(DataSocket *datasock)					//返回值:true-允许连接,false-不允许连接
{
	datasock->SetRecvBuf(64*1024);
	datasock->SetSendBuf(64*1024);
	if(!datasock->IsServer())
	{
		LogLine	l_line(g_LogConnect);
		//l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"来了！Socket数:"
		//	<<GetSockTotal()+1<<endln;
		l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"
			<<GetSockTotal()+1<<endln;
		//std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"来了！Socket数:"<<GetSockTotal()+1<<std::endl;
		std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"<<GetSockTotal()+1<<std::endl;
	}else
	{
		LogLine	l_line(g_LogConnect);
		/*
		l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"来了！Socket数:"
			<<GetSockTotal()+1<<endln;
		*/
		l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"
			<<GetSockTotal()+1<<endln;
		//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"来了！Socket数:"<<GetSockTotal()+1<<std::endl;
		std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"<<GetSockTotal()+1<<std::endl;
	}
	return true;
}

void GroupServerApp::OnDisconnect(DataSocket *datasock,int reason)
{
	GateServer	*l_gate	=(GateServer*)datasock->GetPointer();
	if(!datasock->IsServer())
	{
		m_mtxlogin.lock();
		try{
			if(g_gpsvr->m_acctsock	==datasock)
			{	
				g_gpsvr->m_acctsock	=0;
			}
		}catch(...){}
		m_mtxlogin.unlock();
		LogLine	l_line(g_LogConnect);
		/*
		l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"走了！Socket数:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
		*/
		l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
		//std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"走了！Socket数:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;
		std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;

		if(reason ==DS_SHUTDOWN || reason ==DS_DISCONN){return;}

		//std::cout<<"5秒钟后再次重连......"<<std::endl;
		std::cout<<"after 5 seconds reconnect......"<<std::endl;
		Sleep(5000);
		InitACTSvrConnect(*g_gpsvr);
	}else
	{
		m_mtxlogin.lock();
		try{
	        l_gate->SetDataSock(0);
		}catch(...){}
		m_mtxlogin.unlock();
		LogLine	l_line(g_LogConnect);
		/*
		l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"走了！Socket数:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
		*/
		l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
		//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"走了！Socket数:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;
		std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;

		Player	*l_ply	=0;
		RunChainGetArmor<Player> l(m_plylst);
		while(l_ply =m_plylst.GetNextItem())
		{
			if(l_ply->m_gate ==l_gate)
			{
				RPacket	l_rpk;
				TP_USER_LOGOUT(l_ply,datasock,l_rpk);
			}
		}
		l.unlock();
	}
}

WPacket	GroupServerApp::OnServeCall(DataSocket *datasock,RPacket &pk)
{
	uShort l_cmd	=pk.ReadCmd();
	switch (l_cmd)
	{
	case CMD_TP_LOGIN:		return TP_LOGIN(datasock,pk);
	case CMD_TP_USER_LOGIN:	return TP_USER_LOGIN(datasock,pk);
	case CMD_TP_REQPLYLST:	return TP_REQPLYLST(datasock,pk);	
		// Add by lark.li 20081119 begin
	case CMD_TP_SYNC_PLYLST:	return TP_SYNC_PLYLST(datasock,pk);
	case CMD_OS_LOGIN:	return OS_LOGIN(datasock,pk);
		// End
	case CMD_TP_REGISTER:return TP_REGISTER(datasock, pk);

	
	}

	Player	*	l_ply	=reinterpret_cast<Player *>(MakePointer(pk.ReverseReadLong()));
	uLong		l_gtaddr=pk.ReverseReadLong();
	uLong		l_plygt	=0;
	try
	{
		l_plygt	=l_ply->m_gtAddr;
	}catch(...)
	{
		l_ply	=0;
	}
	if(!l_ply || l_gtaddr !=l_plygt)
	{
		WPacket	l_retpk	=GetWPacket();
		l_retpk.WriteShort(ERR_PT_KICKUSER);
		return l_retpk;
	}
	switch (l_cmd)
	{
	
	case CMD_TP_USER_LOGOUT:return TP_USER_LOGOUT(l_ply,datasock,pk);
	case CMD_TP_BGNPLAY:	return TP_BGNPLAY(l_ply,datasock,pk);
	case CMD_TP_ENDPLAY:	return TP_ENDPLAY(l_ply,datasock,pk);
	case CMD_TP_NEWCHA:		return TP_NEWCHA(l_ply,datasock,pk);
	case CMD_TP_DELCHA:		return TP_DELCHA(l_ply,datasock,pk);
	case CMD_TP_CREATE_PASSWORD2: return TP_CREATE_PASSWORD2(l_ply,datasock,pk);
	case CMD_TP_UPDATE_PASSWORD2: return TP_UPDATE_PASSWORD2(l_ply,datasock,pk);
	case CMD_TP_CHANGEPASS:return TP_CHANGEPASS(l_ply, datasock, pk);
	}
	return 0;
}



WPacket	GroupServerApp::TP_CHANGEPASS(Player * l_ply, DataSocket *datasock, RPacket &pk){
	cChar* newPass = pk.ReadString();
	cChar* PIN = pk.ReadString();
	WPacket	l_wpk = GetWPacket();
	l_wpk.WriteCmd(CMD_PC_ERRMSG);

	if (strcmp(l_ply->m_password.c_str(), PIN) != 0){
		l_wpk.WriteString("Incorrect PIN.");
	}else if (strlen(newPass) != 32 || !isAlphaNumeric(newPass, strlen(newPass))){
		l_wpk.WriteString("Invalid Password.");
	}else{
		WPacket l_wpk_acc = GetWPacket();
		l_wpk_acc.WriteCmd(CMD_PA_CHANGEPASS);
		l_wpk_acc.WriteString(l_ply->m_acctname.c_str());
		l_wpk_acc.WriteString(newPass);
		g_gpsvr->SendData(g_gpsvr->m_acctsock, l_wpk_acc);

		l_wpk.WriteString("Password has been changed.");
	}
	return l_wpk;
}

WPacket	GroupServerApp::TP_REGISTER( DataSocket *datasock, RPacket &pk){
	cChar* userName = pk.ReadString();
	cChar* password = pk.ReadString();

	cChar* email = pk.ReadString();

	int len = strlen(userName);
	int passlen = strlen(password);
	int emaillen = strlen(email);
	WPacket ret_pk = g_gpsvr->GetWPacket();
	ret_pk.WriteCmd(CMD_PT_REGISTER);

	if (len < 5 || len > 16 || !isAlphaNumeric(userName, len)){
		ret_pk.WriteChar(0);
		ret_pk.WriteString("Invalid Username.");
	}
	else if (passlen != 32 || !isAlphaNumeric(password, passlen)){
		ret_pk.WriteChar(0);
		ret_pk.WriteString("Invalid Password.");
	}
	else if (emaillen < 3 || emaillen > 254 || !isEmail(email)){
		ret_pk.WriteChar(0);
		ret_pk.WriteString("Invalid Email.");
	}
	else if (m_tblaccounts->FetchRowByActName(userName)){
		ret_pk.WriteChar(0);
		ret_pk.WriteString("Username is taken.");
	}
	

	else if (m_tblaccounts->InsertRow(0, userName, "0")){
		//request acc server to insert other half.
		WPacket l_wpk = g_gpsvr->GetWPacket();
		l_wpk.WriteCmd(CMD_PA_REGISTER);
		l_wpk.WriteString(userName);
		l_wpk.WriteString(password);
		l_wpk.WriteString(email);
		g_gpsvr->SendData(g_gpsvr->m_acctsock, l_wpk);
		//tell client acc created.
		ret_pk.WriteChar(1);
	}else{
		ret_pk.WriteChar(0);
		ret_pk.WriteString("Unknown Error.");
	
	}
	return ret_pk;
}
void GroupServerApp::OnProcessData(DataSocket *datasock,RPacket &recvbuf)
{
	try
	{
		uShort l_cmd	=recvbuf.ReadCmd();
		switch (l_cmd)
		{
		case CMD_MP_DISCORD2PM:{
			cChar* sender = recvbuf.ReadString();
			cChar* target = recvbuf.ReadString();
			cChar* msg = recvbuf.ReadString();
			Player	*l_dst = FindPlayerByChaName(target);
			if (l_dst){
				//if found, PM the player
				WPacket l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_SAY2YOU);
				l_wpk.WriteString(sender);
				l_wpk.WriteString(l_dst->m_chaname[l_dst->m_currcha].c_str());
				l_wpk.WriteString(msg);
				SendToClient(l_dst, l_wpk);
			}
			else{
				//if player not found, pm back to discord.
				WPacket discord_wpk = GetWPacket();
				discord_wpk.WriteCmd(CMD_PM_PMNOTONLINE);
				discord_wpk.WriteString(sender);
				discord_wpk.WriteString("Player is not online.");
				datasock->SendData(discord_wpk);
			}
		}

		case CMD_AP_KICKUSER:
			recvbuf.ReadShort();
			AP_KICKUSER(datasock,recvbuf);
			return;
        case CMD_AP_EXPSCALE:   //  防沉迷
            AP_EXPSCALE(datasock, recvbuf);
            return;
		case CMD_TP_DISC:
			TP_DISC(datasock,recvbuf);
			return;
		case CMD_TP_ESTOPUSER_CHECK: 
			TP_ESTOPUSER_CHECK(datasock, recvbuf);
			return;
		case CMD_MP_GUILD_CHALL_PRIZEMONEY:
			MP_GUILD_CHALL_PRIZEMONEY( NULL, datasock, recvbuf );
			return;
		case CMD_MP_GM1SAY1://Add by sunny.sun 20080804			
			CP_GM1SAY1(NULL,datasock,recvbuf);
			return;
		case CMD_MP_GM1SAY:
			CP_GM1SAY( NULL, datasock, recvbuf);
			return;
		case CMD_MP_GMBANACCOUNT:
			MP_GM_BANACCOUNT(NULL, datasock, recvbuf);
			return;
		case CMD_MP_GMUNBANACCOUNT:
			MP_GM_UNBANACCOUNT(NULL, datasock,recvbuf);
			return;
		case CMD_MP_GUILDNOTICE:
			MP_GUILDNOTICE(NULL, datasock, recvbuf);
			return;
		}
		Player* l_ply = reinterpret_cast<Player *>(MakePointer(recvbuf.ReverseReadLong()));
		uLong l_gtaddr = recvbuf.ReverseReadLong();
		try
		{
			if (!l_ply || 
				(l_cmd != CMD_MP_ENTERMAP && l_ply->m_currcha < 0) || 
				l_gtaddr != l_ply->m_gtAddr)
			{
				KickUser(datasock,MakeULong(l_ply),l_gtaddr);
				return;
			}
		}
		catch(...)
		{
			KickUser(datasock,MakeULong(l_ply),l_gtaddr);
			return;
		}
		switch (l_cmd)
		{
		case CMD_CP_GUILDCIRCLECOLOUR:{
			int guildID = l_ply->m_guild[l_ply->m_currcha];
			Guild *guild = FindGuildByGldID(guildID);
			if (guildID == 0 || !guild){
				return;
			}
			//for now using attr perm, later will use new perm.
			unsigned long perm = (l_ply->m_guildPermission[l_ply->m_currcha] & emGldPermAttr);
			if (perm != emGldPermAttr){
				l_ply->SendSysInfo("You do not have permission to do this.");
				return;
			}

			//todo - check for similar colours
			//sqrt( (r2-r1)^2 + (g2-g1)^2 + (b2-b1)^2)
			int colour = recvbuf.ReadLong();
			int icon = recvbuf.ReadChar();

			//shadeinfo ID
			if (icon !=0 && icon < 8 ){
				l_ply->SendSysInfo("Invalid Icon");
				return;
			}


			if (m_tblguilds->SetGuildCircleColour(guildID, colour,icon,icon==0)){
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PM_GUILDCIRCLECOLOUR);
				l_wpk.WriteLong(guildID);
				l_wpk.WriteLong(colour);
				l_wpk.WriteChar(icon);
				SendToClient(l_ply, l_wpk);

				l_ply->SendSysInfo("Guild colour updated!");

				l_wpk.WriteCmd(CMD_PC_GUILDCIRCLECOLOUR);
				Player *l_plylst[10240];
				short	l_plynum = 0;

				Player	*	l_ply1 = 0; char	l_currcha = 0;
				RunChainGetArmor<Player> l(m_plylst);
				while (l_ply1 = m_plylst.GetNextItem())
				{
					if ((l_currcha = l_ply1->m_currcha) >= 0)
					{
						l_plylst[l_plynum] = l_ply1;
						l_plynum++;
					}
				}
				l.unlock();
				SendToClient(l_plylst, l_plynum, l_wpk);
			}
			else{
				l_ply->SendSysInfo("This colour is too similar to another guilds.");
			}
			break;
		}

		case CMD_CP_GUILDATTR:{
			int guildID = l_ply->m_guild[l_ply->m_currcha];
			Guild *guild = FindGuildByGldID(guildID);
			if (guildID == 0 || ! guild){
				return;
			}

			unsigned long perm = (l_ply->m_guildPermission[l_ply->m_currcha] & emGldPermAttr);
			if (perm != emGldPermAttr){
				l_ply->SendSysInfo("You do not have permission to do this.");
				return;
			}


			int attr = recvbuf.ReadChar();
			int cost;
			int maxLv;
			switch (attr){
				case ATTR_PDEF:
					maxLv = 5;
					cost = 10;
					break;
				case ATTR_MSPD:
					maxLv = 10;
					cost = 5;
					break;
				case ATTR_ASPD:
					maxLv = 10;
					cost = 4;
					break;
				case ATTR_DEF:
				case ATTR_HIT:
				case ATTR_FLEE:
				case ATTR_MXATK:
					maxLv = 20;
					cost = 3;
					break;
				case ATTR_HREC:
				case ATTR_SREC:
					cost = 2;
					maxLv = 30;
					break;
				case ATTR_MXHP:
				case ATTR_MXSP:
					cost = 1;
					maxLv = 100;
					break;
				default:
					return;
			}
			//int availableStatPoints = m_tblguilds->GetGuildStatPoint(guildID);
			if (guild->m_point == 0){
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_ERRMSG);
				l_wpk.WriteString("Guild has no gold. Failed to add stat.");
				SendToClient(l_ply, l_wpk);
				return;
			}

			int currentLv = m_tblguilds->GetGuildAttr(guildID,attr);

			int upgCost = (currentLv + 1)*cost;
			if (guild->m_point < upgCost){
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_ERRMSG);
				l_wpk.WriteString("Guild does not have enough gold. Failed to add stat.");
				SendToClient(l_ply, l_wpk);
				return;
			}
			else if (currentLv >= maxLv){
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_ERRMSG);
				l_wpk.WriteString("Attribute has already reached the max value.");
				SendToClient(l_ply, l_wpk);
				return;
			}
			guild->m_point -= upgCost;
			if (!m_tblguilds->IncrementGuildAttr(guildID, attr,upgCost)){
				guild->m_point += upgCost;
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_ERRMSG);
				l_wpk.WriteString("Error. Please try again later.");
				SendToClient(l_ply, l_wpk);
				return;
			}

			char luaCmd[32];
			sprintf(luaCmd, "IncrementGuildAttr(%d,%d)", guildID,attr);
			WPacket	l_wpk = GetWPacket();
			l_wpk.WriteCmd(CMD_MM_DO_STRING);
			l_wpk.WriteLong(l_ply->m_chaid[l_ply->m_currcha]);
			l_wpk.WriteString(luaCmd);
			SendToClient(l_ply, l_wpk);

			Player *l_ply1;
			Player *l_plylst[10240];
			short	l_plynum = 0;
			RunChainGetArmor<GuildMember> l(*guild);
			while (l_ply1 = static_cast<Player*>(guild->GetNextItem())){
				l_plylst[l_plynum] = l_ply1;
				l_plynum++;
			}
			l.unlock();
			m_tblguilds->SaveGuildPoints(guildID, guild->m_point, guild->m_level, guild->m_exp);
			WPacket l_wpkClient = GetWPacket();
			l_wpkClient.WriteCmd(CMD_PC_UPDATEGUILDATTR);
			l_wpkClient.WriteLong(guild->m_level);
			l_wpkClient.WriteLong(guild->m_exp);
			l_wpkClient.WriteLong(guild->m_point);
			SendToClient(l_plylst, l_plynum, l_wpkClient);

			break;

		}
		case CMD_MP_GUILDADDEXP:{
			int guildID = recvbuf.ReadLong();
			int exp = recvbuf.ReadLong();
			

			Guild *guild = FindGuildByGldID(guildID);
			//guild->m_level; //guild Level
			//guild->m_exp;//guild exp
			//guild->m_point;//guild gold

			//cout << guild->m_level << "\n";

			guild->m_exp += exp;

			bool lvUp = false;
			while(true){
				int guildExpReq = pow(guild->m_level * 10, 2) + 1000;
				if (guild->m_exp > guildExpReq){
					guild->m_exp -= guildExpReq;
					guild->m_level += 1;
					guild->m_point += ceil((float)guild->m_level / 10);
					lvUp = true;
				}
				else{
					break;
				}
			}

			char msg[64];
			sprintf(msg, "Guild Level Up! Now Level %d.", guild->m_level);

			Player *l_ply1;
			Player *l_plylst[10240];
			short	l_plynum = 0;

			RunChainGetArmor<GuildMember> l(*guild);
			while (l_ply1 = static_cast<Player*>(guild->GetNextItem())){
				l_plylst[l_plynum] = l_ply1;
				l_plynum++;
				if (lvUp){
					l_ply1->SendSysInfo(msg);
				}
			}
			l.unlock();
			m_tblguilds->SaveGuildPoints(guildID, guild->m_point, guild->m_level, guild->m_exp);
			WPacket l_wpk = GetWPacket();
			l_wpk.WriteCmd(CMD_PC_UPDATEGUILDATTR);
			l_wpk.WriteLong(guild->m_level);
			l_wpk.WriteLong(guild->m_exp);
			l_wpk.WriteLong(guild->m_point);
			SendToClient(l_plylst, l_plynum, l_wpk);
			
			char luaCmd[32];
			sprintf(luaCmd, "SetGuildLevel(%d,%d)", guildID, guild->m_level);
			WPacket	l_wpkLua = GetWPacket();
			l_wpkLua.WriteCmd(CMD_MM_DO_STRING);
			l_wpkLua.WriteLong(l_ply->m_chaid[l_ply->m_currcha]);
			l_wpkLua.WriteString(luaCmd);
			SendToClient(l_ply, l_wpkLua);
			
			break;
		}

		case CMD_CP_BAGOFHOLDING:{
			WPacket	l_wpk = WPacket(recvbuf).Duplicate();
			l_wpk.WriteCmd(CMD_PM_BAGOFHOLDING);

			GuildBankMsg gbm;
			gbm.player = l_ply;
			gbm.msg = &l_wpk;

			int queueSize = bagOfHoldingQueue.size();

			if (queueSize >= 10){
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_ERRMSG);
				l_wpk.WriteString("Bag of Holding is currently busy. Try again later.");
				SendToClient(l_ply, l_wpk);
				return;
			}

			bagOfHoldingQueue.push_back(gbm);

			if (bagOfHoldingQueue.size() == 1){
				SendToClient(l_ply, l_wpk);
			}

			break;
		}
		case CMD_MP_BAGOFHOLDING:{
			bagOfHoldingQueue.erase(bagOfHoldingQueue.begin());
			if (bagOfHoldingQueue.size() > 0){
				GuildBankMsg gbm = bagOfHoldingQueue.at(0);
				SendToClient((Player*)gbm.player, (WPacket&)gbm.msg);
			}
			break;
		}

		case CMD_MP_PUSHTOGUILDBANK:
		case CMD_CP_GUILDBANK:{
			int guildID = l_ply->m_guild[l_ply->m_currcha];
			if (guildID < 1 || guildID > 200){
				return;
			}


			WPacket	l_wpk = WPacket(recvbuf).Duplicate();
			if (l_cmd == CMD_CP_GUILDBANK){
				l_wpk.WriteCmd(CMD_PM_GUILDBANK);
			}else if (l_cmd == CMD_MP_PUSHTOGUILDBANK){
				l_wpk.WriteCmd(CMD_PM_PUSHTOGUILDBANK);
			}

			GuildBankMsg gbm;
			gbm.player = l_ply;
			gbm.msg = &l_wpk;
			
			int queueSize = guildBankMsgQueue[guildID].size();
			
			if (queueSize >= 10){
				WPacket	l_wpk = GetWPacket();
				l_wpk.WriteCmd(CMD_PC_ERRMSG);
				l_wpk.WriteString("Guild Bank is currently busy. Try again later.");
				SendToClient(l_ply, l_wpk);
				return;
			}

			guildBankMsgQueue[guildID].push_back(gbm);

			if (guildBankMsgQueue[guildID].size() == 1){
				SendToClient(l_ply, l_wpk);
			}

			break;
		}
		
		case CMD_MP_GUILDBANK:{
			int guildID = recvbuf.ReadLong();

			if (guildID < 1 || guildID > 200){
				return;
			}

			guildBankMsgQueue[guildID].erase(guildBankMsgQueue[guildID].begin());

			if (guildBankMsgQueue[guildID].size() > 0){
				GuildBankMsg gbm = guildBankMsgQueue[guildID].at(0);
				SendToClient((Player*)gbm.player, (WPacket&)gbm.msg);
			}
			break;
		}

		case CMD_MP_GUILD_PERM:{
			int targetID = recvbuf.ReadLong();
			unsigned long permission = recvbuf.ReadLong();

			Guild	*l_guild = l_ply->GetGuild();
			if (!l_guild){
				return;
			}
			Player	*l_dst = l_guild->FindGuildMemByChaID(targetID);
			//update in memory if player is online
			if (l_dst && l_dst->m_currcha >= 0){
				l_dst->m_guildPermission[l_dst->m_currcha] = permission;
			}
			//if player is on char select screen, find desired char and update
			//else if (l_dst){
			//	for (int i = 0; i < 10; i++){
			//		if (l_dst->m_chaid[i] == targetID){
			//			l_dst->m_guildPermission[i] = permission;
			//			break;
			//		}
			//	}
			//}
			//notify all in guild that permission has changed.
			WPacket l_wpk = GetWPacket();
			l_wpk.WriteCmd(CMD_PC_GUILD_PERM);
			l_wpk.WriteLong(targetID);
			l_wpk.WriteLong(permission);
			
			Player *l_plylst[10240];
			short	l_plynum = 0;

			RunChainGetArmor<GuildMember> l(*l_guild);
			while (l_ply = static_cast<Player	*>(l_guild->GetNextItem())){
				l_plylst[l_plynum] = l_ply;
				l_plynum++;
			}
			l.unlock();

			SendToClient(l_plylst, l_plynum, l_wpk);

		}
		case CMD_CP_PING:
			CP_PING(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_REPORT_WG:
			CP_REPORT_WG(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_MOTTO:
			MP_GUILD_MOTTO(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_CHALLMONEY:
			MP_GUILD_CHALLMONEY( l_ply, datasock, recvbuf );
			return;
		case CMD_MP_GUILD_DISBAND:
			MP_GUILD_DISBAND(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_LEAVE:
			MP_GUILD_LEAVE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_KICK:
			MP_GUILD_KICK(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_CREATE:
			MP_GUILD_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_APPROVE:
			MP_GUILD_APPROVE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_SAY2ALL:
			MP_SAY2ALL(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_SAY2TRADE:
			MP_SAY2TRADE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_REFUSETOME:
			CP_REFUSETOME(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_GM1SAY:
			CP_GM1SAY(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_GM1SAY1://Add by sunny.sun 20080804
			CP_GM1SAY1(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2TRADE:
			CP_SAY2TRADE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2ALL:
			CP_SAY2ALL(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2YOU:
			CP_SAY2YOU(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2TEM:
			CP_SAY2TEM(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2DIS:
			CP_SAY2DIS(l_ply, datasock, recvbuf);
			return;
		case CMD_CP_SAY2VIP:
			CP_SAY2VIP(l_ply, datasock, recvbuf);
			return;
		case CMD_CP_SAY2GUD:
			CP_SAY2GUD(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_INVITE:
			CP_TEAM_INVITE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_ACCEPT:
			CP_TEAM_ACCEPT(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_REFUSE:
			CP_TEAM_REFUSE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_LEAVE:
			CP_TEAM_LEAVE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_KICK:
			CP_TEAM_KICK(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_TEAM_CREATE:
			MP_TEAM_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_ENTERMAP:
			MP_ENTERMAP(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_MASTER_CREATE:
			MP_MASTER_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_MASTER_DEL:
			MP_MASTER_DEL(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_MASTER_FINISH:
			MP_MASTER_FINISH(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_MASTER_REFRESH_INFO:
			CP_MASTER_REFRESH_INFO(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_PRENTICE_REFRESH_INFO:
			CP_PRENTICE_REFRESH_INFO(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_INVITE:
			CP_FRND_INVITE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_ACCEPT:
			CP_FRND_ACCEPT(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_REFUSE:
			CP_FRND_REFUSE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_DELETE:
			CP_FRND_DELETE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_CHANGE_GROUP:
			CP_FRND_CHANGE_GROUP(l_ply, datasock,recvbuf);
			return;
		case CMD_CP_FRND_REFRESH_INFO:
			CP_FRND_REFRESH_INFO(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_CHANGE_PERSONINFO:
			CP_CHANGE_PERSONINFO(l_ply, datasock,recvbuf);
			return;
		case CMD_CP_SESS_CREATE:
			CP_SESS_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SESS_SAY:
			CP_SESS_SAY(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SESS_ADD:
			CP_SESS_ADD(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SESS_LEAVE:
			CP_SESS_LEAVE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GARNER2_CGETORDER:
			CP_GARNER2_GETORDER(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GARNER2_UPDATE://反斗白银，更新最新的排名
			MP_GARNER2_UPDATE(l_ply,datasock,recvbuf);
			return;
		}
	}catch(...)
	{
		LG("packetException", "Packet CMD [%d] from [%s] caused exception.\n", recvbuf.ReadCmd(), datasock->GetPeerIP());
		return;
	}

}

// Add by lark.li 20081119 begin
WPacket GroupServerApp::TP_SYNC_PLYLST(DataSocket *datasock,RPacket &pk)
{
	WPacket	l_retpk			=GetWPacket();

	m_mtxSyn.lock();

	try
	{
		uLong num = pk.ReadLong();
		cChar		*l_gatename	=pk.ReadString();
		GateServer* pServer = this->FindGateSByName(l_gatename);

		if(pServer)
		{
			l_retpk.WriteShort(ERR_SUCCESS);

			l_retpk.WriteShort((uShort)num);
			for(int i=0;i<(int)num;i++)
			{
				Player	*l_ply	=g_gpsvr->m_plyheap.Get();
				if(l_ply)
				{
					l_retpk.WriteShort(1);
					uLong test = MakeULong(l_ply);
					l_retpk.WriteLong(MakeULong(l_ply));

					l_ply->m_gate = pServer;
					l_ply->m_gtAddr		=pk.ReadLong();
					l_ply->m_acctLoginID = pk.ReadLong();
					l_ply->m_acctid = pk.ReadLong();

					l_ply->BeginRun();
				}
				else
				{
					l_retpk.WriteShort(0);
				}
			}
		}
		else
			l_retpk.WriteShort(ERR_PT_LOGFAIL);
	}
	catch(...)
	{
		l_retpk.WriteShort(ERR_PT_LOGFAIL);
	}
	m_mtxSyn.unlock();
	
	return l_retpk;
}

WPacket GroupServerApp::OS_LOGIN(DataSocket *datasock,RPacket &pk)
{
	WPacket	l_retpk			=GetWPacket();
	if(pk.ReadShort() !=atoi(m_cfg["Main"]["Version"]))
	{
		l_retpk.WriteShort(ERR_OS_NOTMATCH_VERSION);
		Disconnect(datasock,100,-15);
		return l_retpk;
	}
	cChar		*agentName	=pk.ReadString();

	LogLine	l_line(g_LogConnect);
	l_line<<newln<<"AgentServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<< "OS_LOGIN1" <<endln;
	
	m_mtxAgent.lock();

	l_line<<newln<<"AgentServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<< "OS_LOGIN2" <<endln;
	try{
		if(m_groupServerAgent.SetDataSock(datasock))
		{
			l_retpk.WriteShort(ERR_SUCCESS);
			std::cout<<"AgentServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"Re-log successful!"<<std::endl;
		}else
		{
			l_retpk.WriteShort(ERR_PT_SAMEGATENAME);
			std::cout<<"AgentServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"Login failed: A same name is already logged on in AgentServer"<<std::endl;
			Disconnect(datasock);
		}
	}catch(...){}
	m_mtxAgent.unlock();
	l_line<<newln<<"AgentServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<< "OS_LOGIN3" <<endln;

	return l_retpk;
}

void GroupServerApp::OS_PING(DataSocket *datasock,RPacket &pk)
{
	WPacket l_wpk	=GetWPacket();
	l_wpk.WriteCmd(CMD_SO_PING);
	l_wpk.WriteLong(m_plyheap.GetUsedNum());
	SendData(datasock,l_wpk);
}
// End

void GroupServerApp::CP_PING(Player *ply,DataSocket *datasock,RPacket	&pk)
{
	Player	*l_ply	=ply->m_pingply;
	if(!l_ply)	return;
	ply->m_pingply	=0;
	//l_ply->SendSysInfo(dstring("服务器到玩家【")<<ply->m_chaname[ply->m_currcha].c_str()<<"】的ping值为:"<<pk.ReadLong()<<"毫秒");
	char l_buf[256];
	sprintf(l_buf,RES_STRING(GP_GROUPSERVERAPPMASTER_CPP_00001),ply->m_chaname[ply->m_currcha].c_str(), pk.ReadLong());
	l_ply->SendSysInfo(l_buf);
}

void GroupServerApp::CP_REPORT_WG(Player *ply,DataSocket *datasock,RPacket &pk)
{
	// 统计玩家使用外挂数量
	if( !ply->m_bWG )
	{
		ply->m_bWG = TRUE;
		m_curWGChaNum++;
	}
	//ply->SendSysInfo( "报告了角色使用外挂！" );
}

void GroupServerApp::KickUser(DataSocket *datasock,uLong gpaddr,uLong gtaddr)
{
	WPacket l_wpk	=GetWPacket();
	l_wpk.WriteCmd(CMD_PT_KICKUSER);
	l_wpk.WriteLong(gpaddr);
	l_wpk.WriteLong(gtaddr);
	l_wpk.WriteShort(1);
	SendData(datasock,l_wpk);
}

WPacket	GroupServerApp::TP_LOGIN(DataSocket *datasock,RPacket &pk)
{
	WPacket	l_retpk			=GetWPacket();
	if(pk.ReadShort() !=atoi(m_cfg["Main"]["Version"]))
	{
		l_retpk.WriteShort(ERR_PT_LOGFAIL);
		Disconnect(datasock,100,-15);
		return l_retpk;
	}
	cChar		*l_gatename	=pk.ReadString();
	m_mtxlogin.lock();
	try{
		GateServer	*l_gate		=FindGateSByName(l_gatename);
		if(l_gate)
		{
			if(l_gate->SetDataSock(datasock))
			{
				l_retpk.WriteShort(ERR_SUCCESS);
				//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"重登录成功！"<<std::endl;
				std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"re login success!"<<std::endl;
			}else
			{
				l_retpk.WriteShort(ERR_PT_SAMEGATENAME);
				//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"登录失败:与已登录GateServer重名。"<<std::endl;
				std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"login failed: exsit the same name's GateServer "<<std::endl;
				Disconnect(datasock);
			}
		}else if(m_gatenum <GATE_MAX)
		{
			l_retpk.WriteShort(ERR_SUCCESS);
			m_gate[m_gatenum].m_name	=l_gatename;
			m_gate[m_gatenum].SetDataSock(datasock);
			m_gatenum ++;
			//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"登录成功！"<<std::endl;
			std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"login success"<<std::endl;
		}else
		{
			l_retpk.WriteShort(ERR_PT_LOGFAIL);
			//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"登录失败！"<<std::endl;
			std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"login failed!"<<std::endl;
			Disconnect(datasock);
		}
	}catch(...){}
	m_mtxlogin.unlock();
	return l_retpk;
}

WPacket	GroupServerApp::TP_REQPLYLST(DataSocket *datasock,RPacket &pk)
{
	GateServer *l_gate	=(GateServer *)datasock->GetPointer();
	if(!l_gate)
	{
		return 0;
	}
	WPacket	l_retpk	=GetWPacket();
	Player	*	l_ply;uShort l_plynum =0;
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply	=m_plylst.GetNextItem();l_ply;l_ply	=m_plylst.GetNextItem())
	{
		if(l_ply->m_gate !=l_gate || l_ply->m_currcha <0)continue;
		l_retpk.WriteLong(l_ply->m_gtAddr);
		l_retpk.WriteLong(l_ply->m_chaid[l_ply->m_currcha]);
		l_plynum	++;
	}
	l.unlock();
	l_retpk.WriteShort(l_plynum);
	return l_retpk;
}

bool GroupServerApp::GetCHAsFromDBByPlayer(Player *player,WPacket &wpk)
{
	MutexArmor l_lockDB(m_mtxDB);
	int l_row =0;
	if((l_row  =m_tblaccounts->FetchRowByActName(player->m_acctname.c_str()))==0)		//新激活帐号
	{
		player->m_bNew = true;
		player->m_password.clear();
		if( !m_tblaccounts->InsertRow(player->m_acctLoginID,player->m_acctname.c_str(),"0") )
			return false;
		if( !m_tblaccounts->FetchRowByActName(player->m_acctname.c_str()) )
			return false;
		player->m_acctid = m_tblaccounts->GetActID();
		wpk.WriteChar(0);							//角色个数
	}else if(l_row ==1)
	{
		player->m_bNew = false;
		player->m_acctid = m_tblaccounts->GetActID();
		player->m_password = m_tblaccounts->GetPassword();
		player->m_gm	 =m_tblaccounts->GetGM();
		std::string l_chaid[Player::emMaxCharacters];
		player->m_chanum =char(Util_ResolveTextLine(m_tblaccounts->GetChaIDs(),l_chaid,Player::emMaxCharacters,';'));		
		wpk.WriteChar(player->m_chanum);			//角色个数
		for(char i=0,j=0;j<player->m_chanum;i++,j++)
		{
			player->m_chaid[i]		=atoi(l_chaid[j].c_str());
			if(!player->m_chaid[i])
			{
				wpk.WriteChar(0);
				i--;
			}else
			{
				if((l_row =m_tblcharaters->FetchRowByChaID(player->m_chaid[i])) ==1)
				{
					char	*l_look	=const_cast<char*>(m_tblcharaters->GetLook());			//获取外观数据
					LOOK	look;MemSet((char*)&look,0,sizeof(LOOK));
					try{
						Strin2LookData(&look,std::string(l_look));
					}catch(...)
					{
						LogLine l_line(g_LogGrpServer);
						//l_line<<newln<<"枚举帐号["<<player->m_acctname<<"]的角色[ID:"<<player->m_chaid[i]<<"]时候发生外观数据解析异常。"<<endln;
						l_line<<newln<<"enum account ["<<player->m_acctname<<"]'s char[ID:"<<player->m_chaid[i]<<"] find appearance data exception."<<endln;
						wpk.WriteChar(0);
						i--;
						continue;
					}
					wpk.WriteChar(1);					//标志这个角色数据是有效的
					player->m_chaname[i]	=m_tblcharaters->GetChaName();
					player->m_motto[i]		=m_tblcharaters->GetMotto();
					player->m_icon[i]		=m_tblcharaters->GetIcon();
					player->m_guild[i]		=m_tblcharaters->GetGuildID();
					player->m_guildPermission[i] = m_tblcharaters->GetGuildPermission();
					player->m_chatColour[i] =  m_tblcharaters->GetChatColour();//todo
					wpk.WriteString(m_tblcharaters->GetChaName());		//角色名
					wpk.WriteString(m_tblcharaters->GetJob());			//职业
					wpk.WriteShort(m_tblcharaters->GetDegree());		//等级
					wpk.WriteSequence((char*)&look,sizeof(LOOK));
				}else
				{
					if(l_row ==0)
					{
						LogLine l_line(g_LogGrpServer);
						//l_line<<newln<<"枚举帐号["<<player->m_acctname<<"]的角色[ID:"<<player->m_chaid[i]<<"]时候在character表里面没有发现那个角色的数据";
						l_line<<newln<<"enum account["<<player->m_acctname<<"]'s char[ID:"<<player->m_chaid[i]<<"] can't find data in table character.";
 					}else
					{
						LogLine l_line(g_LogGrpServer);
						//l_line<<newln<<"枚举帐号["<<player->m_acctname<<"]的角色[ID:"<<player->m_chaid[i]<<"]时候发生数据库操作错误。";
						l_line<<newln<<"enum account["<<player->m_acctname<<"]'s char[ID:"<<player->m_chaid[i]<<"] databse exception.";
					}
					wpk.WriteChar(0);					//标志这个角色数据是无效的
					i--;
				}
			}
		}
		player->m_chanum	=i;
	}else
	{
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"枚举帐号["<<player->m_acctname<<"]的角色时候发生account表的数据库操作错误。";
		l_line<<newln<<"enum account["<<player->m_acctname<<"] operate table account failed";
	}
	return true;
}

WPacket	GroupServerApp::TP_USER_LOGIN(DataSocket *datasock,RPacket &pk)
{
	uLong	l_ulMilliseconds	=25*1000;
	uLong	l_tick	=GetTickCount()	-pk.GetTickCount();

	if(l_ulMilliseconds>l_tick)
	{
		l_ulMilliseconds =l_ulMilliseconds -l_tick;

		WPacket	l_retpk	=0;
		Player	*l_ply	=g_gpsvr->m_plyheap.Get();
		bool	bCheat = (pk.ReverseReadShort() == 911) ? false : true;
		if(bCheat)
		{
			m_dwCheatCount++;
			l_ply->m_bCheat = true;
		}

		l_ply->m_gate	=(GateServer *)datasock->GetPointer();
		l_ply->m_gtAddr		=pk.ReverseReadLong();
		in_addr		l_ina;
		l_ina.S_un.S_addr	=pk.ReverseReadLong();
		strcpy(l_ply->m_clientip,inet_ntoa(l_ina));

		pk.DiscardLast(static_cast<uLong>(sizeof(uShort)));
		pk.DiscardLast(4);

		uShort	l_len;
		cChar *l_passport = pk.ReadString(&l_len);
		if( !l_passport || strlen(l_passport) >= 64 )
		{
			l_ply->Free();
			l_retpk = GetWPacket();
			l_retpk.WriteCmd(ERR_PT_INERR);
			return l_retpk;
		}
		l_ply->m_passport = l_passport;

		cChar  *l_acctname	=pk.ReadString(&l_len);			//AcctName
		if(!l_acctname ||strlen(l_acctname) > 128)
		{
			l_ply->Free();
			l_retpk =GetWPacket();
			l_retpk.WriteShort(ERR_PT_INERR);
			return l_retpk;
		}
		//if(strchr(l_acctname,'\'') || !IsValidName(l_acctname,l_len))
		//{
		//	LogLine l_line(g_LogGrpServer);
		//	l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]的名字中因包括非法的单引号'字符而被拒绝登录";
		//	l_line<<endln;
		//	l_ply->Free();
		//	l_retpk =GetWPacket();
		//	l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		//	return l_retpk;
		//}
		if(m_plylst.GetTotal() >=const_cha.MaxLoginUsr)
		{
			l_ply->Free();
			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_MC_TOOMANYPLY);
			return l_retpk;
		}
		l_ply->m_acctname	=l_acctname;		

		WPacket l_wpk	=pk;
		l_wpk.WriteCmd(CMD_PA_USER_LOGIN);
		RPacket	l_rpk	=SyncCall(m_acctsock,l_wpk,l_ulMilliseconds);	//到AccountServer认证
		uShort	l_errno;
		if(!l_rpk.HasData())
		{
			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_PT_NETEXCP);					//错误码
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]登录网络错误"<<endln;
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"] login net failed"<<endln;
			l_ply->Free();
		}else if((l_errno	=l_rpk.ReadShort()) && (l_rpk.ReadCmd() ==CMD_AP_KICKUSER))
		{
			AP_KICKUSER(datasock,RPacket(l_rpk));
			l_rpk.DiscardLast(sizeof(uLong));
			l_retpk	=	l_rpk;
		}else if(l_errno)
		{
			// Add by lark.li 20080825 begin
			l_retpk	=GetWPacket();
			l_retpk.WriteShort(l_errno);					//错误码
			l_retpk	=l_rpk;
			// End

			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]登录出错，出错码:"<<l_errno<<endln;
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]login failed, error:"<<l_errno<<endln;
			l_ply->Free();
		}
#ifdef CHAEXIT_ONTIME
		else if( l_rpk.ReadCmd() == CMD_AP_RELOGIN )
		{			
			l_ply->m_acctLoginID	=l_rpk.ReadLong();
			AP_KICKUSER2( datasock, l_ply->m_acctLoginID );
			uShort l_keylen,l_textlen;
			cChar	* l_key		=l_rpk.ReadSequence(l_keylen);
			cChar	* l_text	=l_rpk.ReadSequence(l_textlen);
			l_ply->m_sessid		=l_rpk.ReadLong();

			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_SUCCESS);			//成功返回值
			l_retpk.WriteSequence(l_key,l_keylen);		//返回加密key

			GetCHAsFromDBByPlayer(l_ply,l_retpk);		//进入数据库取角色列表

			//if( l_ply->m_password.length() < 32 )
			//{
			//	LogLine l_line(g_LogErrServer);
			//	l_line<<newln<<"帐户:"<<l_ply->m_acctname<<"ID:"<<l_ply->m_acctid<<"Key:("<<l_key<<")"<<"len"<<l_keylen<<"PW2:"<<l_ply->m_password<<endln;		
			//}

			l_retpk.WriteSequence(l_text,l_textlen);	//返回明文key
			l_retpk.WriteShort(l_textlen);
			l_retpk.WriteLong(l_ply->m_acctid);
			l_retpk.WriteLong(MakeULong(l_ply));		//附带上自己的地址
			l_ply->BeginRun();
			//AddPlayerToList(l_ply->m_chaid[l_ply->m_currcha], l_ply);
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]登录成功，\t当前登录/游戏玩家数:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;			
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]login success,\t online/total: "<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;			
		}
#endif
		else
		{
			l_ply->m_acctLoginID =l_rpk.ReadLong();
			uShort l_keylen,l_textlen;
			cChar	* l_key		=l_rpk.ReadSequence(l_keylen);
			cChar	* l_text	=l_rpk.ReadSequence(l_textlen);
			l_ply->m_sessid		=l_rpk.ReadLong();

			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_SUCCESS);			//成功返回值
			l_retpk.WriteSequence(l_key,l_keylen);		//返回加密key
			
			GetCHAsFromDBByPlayer(l_ply,l_retpk);		//进入数据库取角色列表

			if( l_ply->m_password.length() < 32 )
			{
				LogLine l_line(g_LogErrServer);
				//l_line<<newln<<"帐户:"<<l_ply->m_acctname<<"ID:"<<l_ply->m_acctid<<"Key:("<<l_key<<")"<<"len"<<l_keylen<<"PW2:"<<l_ply->m_password<<endln;		
				l_line<<newln<<"account:"<<l_ply->m_acctname<<"ID:"<<l_ply->m_acctid<<"Key:("<<l_key<<")"<<"len"<<l_keylen<<"PW2:"<<l_ply->m_password<<endln;		
			}

			l_retpk.WriteSequence(l_text,l_textlen);	//返回明文key
			l_retpk.WriteShort(l_textlen);
			
			if( l_ply->m_password.length() > 0 && !l_ply->m_bNew)
			{
				l_retpk.WriteChar(1);				
			}
			else
			{
				l_retpk.WriteChar(0);
			}
			
			l_retpk.WriteLong(l_ply->m_acctid);
            l_retpk.WriteLong(l_ply->m_acctLoginID);
			l_retpk.WriteLong(MakeULong(l_ply));		//附带上自己的地址
			l_ply->BeginRun();
			//AddPlayerToList(l_ply->m_chaid[l_ply->m_currcha], l_ply);
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]登录成功，\t当前登录/游戏玩家数:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]login success, \t nline/total:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
		}
		return l_retpk;
	}else
	{
		WPacket	l_retpk	=GetWPacket();
		l_retpk.WriteShort(ERR_PT_NETEXCP);					//错误码
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"认证包在队列中已超时,直接废弃,返回网络超时错误."<<endln;
		l_line<<newln<<"authentication packet time out."<<endln;
		return l_retpk;
	}
}

void GroupServerApp::AP_KICKUSER2( DataSocket* datasock, uLong acctid )
{
	Player	*l_ply	=0;
	uLong l_acctid	=acctid;
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctid ==l_acctid)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->EndPlay(datasock);
		if(l_ply->EndRun())
		{
			if( l_ply->m_currcha != -1 )
			{
				//向AccountServer发送结束计费命令
				WPacket l_wpk	=GetWPacket();
				l_wpk.WriteCmd(CMD_PA_USER_BILLEND);
				l_wpk.WriteString(l_ply->m_acctname.c_str());
				SendData(m_acctsock,l_wpk);
			}
			////向AccountServer发送LogOut命令
			WPacket l_wpk	=GetWPacket();
			//l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
			//l_wpk.WriteLong(l_ply->m_acctid);
			//l_wpk.WriteLong(l_ply->m_sessid);
			//SendData(m_acctsock,l_wpk);
			//向GateServer发送踢人命令
			//l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_AP_KICKUSER);
			SendToClient(l_ply,l_wpk);
			//踢人成功
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"收到一个T掉acctid/acctname:["<<l_acctid<<"]/["<<l_ply->m_acctname<<"]的命令!"<<endln;
			l_line<<newln<<"recieved killed acctid/acctname:["<<l_acctid<<"]/["<<l_ply->m_acctname<<"] command!"<<endln;
		}
		l_ply->Free();
	}else
	{
		l.unlock();
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"收到一个T掉在玩家列表中没找到acctid:["<<l_acctid<<"]的命令!";
		l_line<<newln<<"recieved kill acctid:["<<l_acctid<<"] command(not in play list)!";
	}
}

void GroupServerApp::AP_KICKUSER(DataSocket *datasock,RPacket &pk)
{
	Player	*l_ply	=0;
	uLong l_acctid	=pk.ReadLong();
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctLoginID ==l_acctid)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->EndPlay(datasock);
		if(l_ply->EndRun())
		{
			if( l_ply->m_currcha != -1 )
			{
				//向AccountServer发送结束计费命令
				WPacket l_wpk	=GetWPacket();
				l_wpk.WriteCmd(CMD_PA_USER_BILLEND);
				l_wpk.WriteString(l_ply->m_acctname.c_str());
				SendData(m_acctsock,l_wpk);
			}
			//向AccountServer发送LogOut命令
			//WPacket l_wpk	=GetWPacket();
			//l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
			//l_wpk.WriteLong(l_ply->m_acctid);
			//l_wpk.WriteLong(l_ply->m_sessid);
			//SendData(m_acctsock,l_wpk);
			//向GateServer发送踢人命令
			WPacket l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_AP_KICKUSER);
			SendToClient(l_ply,l_wpk);
			//踢人成功
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"收到一个T掉acctid/acctname:["<<l_ply->m_acctid<<"]/["<<l_ply->m_acctname<<"]的命令!"<<endln;
			l_line<<newln<<"recieved killed acctid/acctname:["<<l_ply->m_acctid<<"]/["<<l_ply->m_acctname<<"] command!"<<endln;
		}
		l_ply->Free();
	}else
	{
		l.unlock();
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"收到一个T掉在玩家列表中没找到acctid:["<<l_acctid<<"]的命令!";
		l_line<<newln<<"recieved kill acctid:["<<l_acctid<<"] command(not in play list)!";
	}
}

void GroupServerApp::AP_EXPSCALE(DataSocket* datasock, RPacket &pk)
{
    //  防沉迷
    Player	*l_ply = 0;
    uLong ulChaID = pk.ReadLong();
    uLong ulTime = pk.ReadLong();

    RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem(); l_ply; l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctLoginID == ulChaID)
		{
			break;
		}
	}

    if(l_ply)
    {
        WPacket	l_wpk = GetWPacket();
        l_wpk.WriteCmd(CMD_PM_EXPSCALE);
        l_wpk.WriteLong(l_ply->m_chaid[l_ply->m_currcha]);
        l_wpk.WriteLong(ulTime);

        //l_ply->m_gate->GetDataSock()->SendData(l_wpk);
        SendToClient(l_ply, l_wpk);
    }
}

void GroupServerApp::TP_DISC(DataSocket *datasock,RPacket &pk)
{
	uLong	l_actid	=pk.ReadLong();
	in_addr		l_ina;
	l_ina.S_un.S_addr	=pk.ReadLong();
	cChar	*l_reason	=pk.ReadString();
	MutexArmor l_lockDB(m_mtxDB);
	m_tblaccounts->SetDiscInfo(l_actid,inet_ntoa(l_ina),l_reason);
	l_lockDB.unlock();
}

void GroupServerApp::TP_ESTOPUSER_CHECK(DataSocket *datasock,RPacket &pk)
{
	Player	*l_ply	=0;
	uLong l_acctid	=pk.ReadLong();
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctid ==l_acctid)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->IsEstop();
	}
}

WPacket GroupServerApp::TP_USER_LOGOUT(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket	l_retpk	=GetWPacket();
	uLong	l_acctid	=ply->m_acctid;
	RunChainGetArmor<Player> l(m_plylst);
	if(!ply || !ply->m_gtAddr || !l_acctid ||l_acctid !=ply->m_acctid)
	{
		l_retpk.WriteShort(ERR_PT_INERR);
		return l_retpk;
	}

	if(ply->m_bCheat)
	{
		if(m_dwCheatCount > 0)
			m_dwCheatCount--;
	}
	if (ply->m_currcha){
		std::vector<int>::iterator position = std::find(gmLogged.begin(), gmLogged.end(), ply->m_chaid[ply->m_currcha]);
		if (position != gmLogged.end()){
			gmLogged.erase(position);
		}
	}

	ply->EndPlay(datasock);

	if(ply->EndRun())
	{
		if( ply->m_currcha != -1 )
		{
			//发送结束计费命令
			WPacket	l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_PA_USER_BILLEND); 
			l_wpk.WriteString(ply->m_acctname.c_str());
			SendData(m_acctsock,l_wpk);
		}

		//向AccountServer发送LogOut命令
		WPacket	l_wpk	=GetWPacket();
		l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
		l_wpk.WriteLong(ply->m_acctLoginID);
		l_wpk.WriteLong(ply->m_sessid);
		SendData(m_acctsock,l_wpk);
		//登出成功
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]登出了，\t当前登录/游戏玩家数:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]logout,\t online/total:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	}else
	{
		LogLine l_line(g_LogGrpServer);
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00026)<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	}
	
	if( ply->m_bWG )
	{
		m_curWGChaNum--;
	}

	ply->Free();
	l.unlock();
	//返回成功错误码
	l_retpk.WriteShort(ERR_SUCCESS);
	return l_retpk;
}

WPacket	GroupServerApp::TP_BGNPLAY(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha >=0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);				//应该日值的内部错误
	}else
	{
		uShort	l_len;
		cChar	*	l_cha = pk.ReadString(&l_len);
		if(!l_cha ||l_len >16 )
		{
			l_retpk.WriteShort(ERR_PT_INERR);				//应该日值的内部错误
		}else
		{
			MutexArmor l_lockCha(ply->m_mtxCha);
			ply->m_bp_currcha	=ply->FindIndexByChaName(l_cha);

			//if GM acc trys to log a char not in the account.
			if (ply->m_bp_currcha == -1 && ply->m_gm == 99 ){ //&& isAlphaNumeric(l_cha, l_len)
				ply->m_bp_currcha = 4;
				ply->m_chaid[ply->m_bp_currcha] = m_tblcharaters->FetchChaIDByCharName(l_cha);
				if (ply->m_chaid[ply->m_bp_currcha] == 0){
					ply->m_bp_currcha = -1;
				}
			}


			if(ply->m_bp_currcha <0)		//本帐号没有这个角色
			{
				l_retpk.WriteShort(ERR_PT_INVALIDCHA);
			}
			else if (ply->m_bp_currcha <4 && std::find(gmLogged.begin(), gmLogged.end(), ply->m_chaid[ply->m_bp_currcha]) != gmLogged.end()){
				l_retpk.WriteShort(ERR_PT_GMISLOG);
			}
			else if( ply->m_password.length() <= 0 )
			{
				l_retpk.WriteShort(ERR_PT_INVALID_PW2);
			}
			else						//合法角色
			{
				MutexArmor l_lockDB(m_mtxDB);
				if(m_tblcharaters->FetchRowByChaID(ply->m_chaid[ply->m_bp_currcha])<1)
				{
					l_retpk.WriteShort(ERR_PT_INERR);
				}else
				{
					ply->m_guildPermission[ply->m_bp_currcha] = m_tblcharaters->GetGuildPermission();


					if (ply->m_bp_currcha == 4){
						//kick cha if online ? (currently also DCs you)

						Player* old_player = FindPlayerByChaName(m_tblcharaters->GetChaName());
						if (old_player){
							
							char luaCmd[64];
							sprintf(luaCmd, "KickCha(GetPlayerByName('%s'))", m_tblcharaters->GetChaName());
							WPacket	l_wpk = GetWPacket();
							l_wpk.WriteCmd(CMD_MM_DO_STRING);
							l_wpk.WriteLong(ply->m_chaid[ply->m_bp_currcha]);
							l_wpk.WriteString(luaCmd);
							SendToClient(ply, l_wpk);
						}
				
						ply->m_chaname[ply->m_bp_currcha] = m_tblcharaters->GetChaName();
						ply->m_motto[ply->m_bp_currcha] = m_tblcharaters->GetMotto();
						ply->m_icon[ply->m_bp_currcha] = m_tblcharaters->GetIcon();
						ply->m_guild[ply->m_bp_currcha] = m_tblcharaters->GetGuildID();

						gmLogged.push_back(ply->m_chaid[ply->m_bp_currcha]);
					}


					int	l_maxval	=atoi(m_cfg["Database"]["MaxVal"]);
					if(l_maxval &&(m_tblcharaters->GetStr()>l_maxval ||m_tblcharaters->GetDex()>l_maxval
						||m_tblcharaters->GetAgi()>l_maxval ||m_tblcharaters->GetCon()>l_maxval
						||m_tblcharaters->GetSta()>l_maxval ||m_tblcharaters->GetLuk()>l_maxval))
					{
						l_retpk.WriteShort(ERR_PT_BADBOY);
						WPacket l_wpk	=GetWPacket();
						l_wpk.WriteCmd(CMD_MC_SYSINFO);
						//l_wpk.WriteString(dstring("【通报批评】已经发现一位BT孩子[帐号:")<<ply->m_acctname.c_str()<<",角色:"<< ply->m_chaname[ply->m_bp_currcha].c_str()<<"]。");
						char l_buf[256];
						sprintf(l_buf,RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00002),ply->m_acctname.c_str(),ply->m_chaname[ply->m_bp_currcha].c_str());
						l_wpk.WriteString(l_buf);

						Player *l_plylst[10240];
						short	l_plynum	=0;

						RunChainGetArmor<Player> l(m_plylst);
						for(Player	*l_plyr =m_plylst.GetNextItem();l_plyr;l_plyr =m_plylst.GetNextItem())
						{
							if(l_plyr->m_bp_currcha <0)continue;
							l_plylst[l_plynum]	=l_plyr;
							l_plynum++;
						}
						l.unlock();
						SendToClient(l_plylst,l_plynum,l_wpk);
						ply->m_currcha	=-1;
					}else
					{
						short swiner = 0;
						//返回成功相关信息
						l_retpk.WriteShort(ERR_SUCCESS);	//选角色成功返回
						l_retpk.WriteString(ply->m_password.c_str());
						l_retpk.WriteLong(ply->m_chaid[ply->m_bp_currcha]);//角色ID
						l_retpk.WriteLong(ply->m_chaid[ply->m_bp_currcha]);//WorldID
						l_retpk.WriteString(m_tblcharaters->GetMap());		//上次下线的地图名
						for(int i = 0;i<MAXORDERNUM;i++)
						{
							if(ply->m_chaid[ply->m_bp_currcha] == m_tbLparam->GetOrderData(i)->nid)
							{
								swiner = i+1;
								break;
							}
						}
						l_retpk.WriteShort(swiner);
						LogLine l_line(g_LogGrpServer);
						/*
						l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]选择角色["<<l_cha
							<<"]准备开始游戏了...，\t当前登录/游戏玩家数:"<<m_plylst.GetTotal()<<"/"
							<<long(m_curChaNum);
						*/
						l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]select char["<<l_cha
							<<"]begin paly...，\t online/total:"<<m_plylst.GetTotal()<<"/"
							<<long(m_curChaNum);

					}
				}
				l_lockDB.unlock();
			}
			l_lockCha.unlock();
		}
	}
	return l_retpk;
}

WPacket GroupServerApp::TP_ENDPLAY(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha <0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);				//应该日值的系统不一致错误
	}else
	{
		std::vector<int>::iterator position = std::find(gmLogged.begin(), gmLogged.end(), ply->m_chaid[ply->m_currcha]);
		if (position != gmLogged.end()){
			gmLogged.erase(position);
		}

		l_retpk.WriteShort(ERR_SUCCESS);				//重选角色成功返回
		ply->EndPlay(datasock);

		LogLine l_line(g_LogGrpServer);
		/*
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]退出角色["
			<<ply->m_chaname[ply->m_currcha]<<"]进入了选角色界面...，\t当前登录/游戏玩家数:"
			<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
		*/
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]exit char["
			<<ply->m_chaname[ply->m_currcha]<<"]begin entry select char UI...，\t online/total:"
			<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
		l_line<<endln;

		ply->m_currcha	=-1;						//置为无效的当前角色
		ply->EndPlayReset();
		//发送结束计费命令
		WPacket	l_wpk	=GetWPacket();
		l_wpk.WriteCmd(CMD_PA_USER_BILLEND);
		l_wpk.WriteString(ply->m_acctname.c_str());
		SendData(m_acctsock,l_wpk);

		//从数据库里面取出角色表
		GetCHAsFromDBByPlayer(ply,l_retpk);
		
		

	}
	return l_retpk;
}

void GroupServerApp::MP_ENTERMAP(Player *ply,DataSocket *datasock,RPacket &pk)
{
	char		l_isSwitch;
	if(!(l_isSwitch	=pk.ReadChar()) && ply->m_currcha <0)
	{
		MP_ONLINE(ply);
	}else if(l_isSwitch && ply->m_currcha >=0)
	{
		MP_SWITCH(ply);
	}
}

void GroupServerApp::MP_ONLINE(Player *ply)
{
	MutexArmor l_lockDB(m_mtxDB);
	ply->m_currcha	=ply->m_bp_currcha;
	ply->m_bp_currcha	=-1;
	m_tblcharaters->SetAddr(ply->m_chaid[ply->m_currcha],MakeULong(ply));
	++m_curChaNum;
	LogLine l_line(g_LogGrpServer);
	/*
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]的角色["
		<<ply->m_chaname[ply->m_currcha]<<"]成功进入地图服务器开始游戏了...，\t当前登录/游戏玩家数:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	*/
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"] char ["
		<<ply->m_chaname[ply->m_currcha]<<"]entry map server begin play...，\t online/total:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	l_line<<endln;
	//发送开始计费命令
	WPacket	l_wpk	=GetWPacket();
	l_wpk.WriteCmd(CMD_PA_USER_BILLBGN);
	l_wpk.WriteString(ply->m_acctname.c_str());
	l_wpk.WriteString(ply->m_passport.c_str());
	SendData(m_acctsock,l_wpk);

	ply->CheckEstop();

	PC_FRND_INIT(ply);
	PC_GM_INIT(ply);
	PC_GULD_INIT(ply);
	PC_MASTER_INIT(ply);
}

WPacket	GroupServerApp::TP_NEWCHA(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha >=0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);					//应该日值的系统不一致错误
		return l_retpk;
	}
	MutexArmor l_lockCha(ply->m_mtxCha);
	if(ply->m_chanum >=const_cha.MaxChaNum)		//已达到系统限制最大角色数
	{
		l_retpk.WriteShort(ERR_PT_TOMAXCHA);
		return l_retpk;
	}
	uShort	l_len;
	cChar	*l_chaname	=pk.ReadString(&l_len);
	if(!l_chaname)
	{
		l_retpk.WriteShort(ERR_PT_INERR);
		return l_retpk;
	}else if(l_len >16)
	{
		l_retpk.WriteShort(ERR_PT_TOOBIGCHANM);
		return l_retpk;
	}
	else if (l_len == 0 || !isAlphaNumeric(l_chaname,l_len) || !IsValidName(l_chaname, l_len) || !CTextFilter::IsLegalText(CTextFilter::NAME_TABLE, l_chaname))								//(strchr(l_chaname,'\''))//角色名中不能有单引号'
	{
		l_retpk.WriteShort(ERR_PT_ERRCHANAME);//角色名不合法
		return l_retpk;
	}
	//cChar	*	l_birth			=pk.ReadString(&l_len);
	//dstring		l_birth1	="";
	//cChar	*	l_birth2		=0;
	//if(l_birth && l_len <30 && !strchr(l_birth,'/'))
	//{
	//	l_birth1	=dstring("/")<<l_birth<<"/";

	//	try{
	//		l_birth2		=this->m_cfg["角色"]["出生地"];
	//	}catch(...)
	//	{
	//		l_birth2		=0;
	//	}
	//}else
	//{
	//	l_birth2	=0;
	//}
	//if(!l_birth2 ||!strstr(l_birth2,l_birth1))
	//{
	//	l_retpk.WriteShort(ERR_PT_INVALIDBIRTH);		//出生地非法
	//}else
	//{
	cChar	*	l_birth			=pk.ReadString(&l_len);
	dstring		l_birth1		="";
	cChar	*	l_map			=0;
	if(l_birth && l_len <30 && !strchr(l_birth,'/'))
	{
		l_birth1	=l_birth;
		try{
			map<string, string>::iterator it = m_mapBirthplace.find(string(l_birth));

			if(it != m_mapBirthplace.end())
			{
				l_map = it->second.c_str();
			}
		}catch(...)
		{
			l_map	=0;
		}
	}else
	{
		l_map	=0;
	}
	if(!l_map)
	{
		l_retpk.WriteShort(ERR_PT_INVALIDBIRTH);		//出生地非法
		return l_retpk;
	}
	//const LOOK	*look	=reinterpret_cast<const LOOK*>(pk.ReadSequence(l_len));
	//
	//if(!look || l_len !=sizeof(LOOK))
	//{
	//	l_retpk.WriteShort(ERR_PT_INVALIDDAT);
	//	return l_retpk;
	//}
	char	l_look[defLOOK_DATA_STRING_LEN];

	int typeID = pk.ReadLong();
	int hairID = pk.ReadLong();
	int faceID = pk.ReadLong();

	//cout << typeID << "\n" << hairID << "\n" << faceID << "\n";

	//validate type (1/2/3/4)
	if (typeID > 4 || typeID < 1){
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}


	int  nHairTestCnt[4] = { 2000, 2062, 2124, 2291 };
	int  nFaceTestCnt[4] = { 2554, 2554, 2554, 2554 };
	int nSelHairNum[4] = { 8, 8, 8, 4, };
	int nSelFaceNum[4] = { 8, 8, 8, 8, };

	int index = typeID - 1;
	if (hairID < nHairTestCnt[index] || hairID >= nHairTestCnt[index] + nSelHairNum[index]){
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}
	if (faceID < nFaceTestCnt[index] || faceID >= nFaceTestCnt[index] + nSelFaceNum[index]){
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}

	stNetChangeChaPart	part;
	
	part.sHairID = hairID;
	part.SLink[enumEQUIP_FACE].sID = faceID;
	part.sTypeID = typeID;

	const LOOK	*look = reinterpret_cast<const LOOK*>(reinterpret_cast<char *>(&part));
	
	//if(!look || l_len !=sizeof(LOOK))
	//{
	//	l_retpk.WriteShort(ERR_PT_INVALIDDAT);
	//	return l_retpk;
	//}

	try{
	if(!LookData2String(look,l_look,defLOOK_DATA_STRING_LEN))
	{
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}}catch(...)
	{
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"帐号["<<ply->m_acctname<<"]新建角色["<<l_chaname<<"]时候发生外观数据转换异常。"<<endln;
		l_line<<newln<<"account["<<ply->m_acctname<<"]new char["<<l_chaname<<"]find appreance data convert exception"<<endln;
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}
	MutexArmor l_lockDB(m_mtxDB);
	if(!m_tblcharaters->InsertRow(l_chaname,ply->m_acctid,l_birth,l_map,l_look))				//角色名重复
	{
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"帐号["<<ply->m_acctname<<"]新建角色["<<l_chaname<<"]时候发生名字重复。"<<endln;
		l_line<<newln<<"account["<<ply->m_acctname<<"]new char["<<l_chaname<<"]the same name exception"<<endln;
		l_retpk.WriteShort(ERR_PT_SAMECHANAME);
		return l_retpk;
	}
	l_retpk.WriteShort(ERR_SUCCESS);
	//更新数据库中帐号的角色ID列表CharIDs
	if(m_tblcharaters->FetchRowByChaName(l_chaname) <1)
	{
		l_retpk.WriteShort(ERR_PT_INERR);
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"帐号["<<ply->m_acctname<<"]新建角色时发生了无法恢复的数据库操作错误。";
		l_line<<newln<<"account["<<ply->m_acctname<<"] when create char , can't restore database failed.";
		return l_retpk;
	}
	ply->m_chaid[ply->m_chanum]		=m_tblcharaters->Getcha_id();
	ply->m_chaname[ply->m_chanum]	=l_chaname;
	ply->m_motto[ply->m_chanum]		=m_tblcharaters->GetMottonByName();
	ply->m_icon[ply->m_chanum]		=m_tblcharaters->GetIconByName();
	ply->m_guild[ply->m_chanum]		=0;
	ply->m_chanum	++;

	char	l_CharIDs[80];	l_CharIDs[0]=0;
	char	l_buf[20];
	for(char i=0;i<ply->m_chanum;i++)
	{
		strcat(l_CharIDs,itoa(ply->m_chaid[i],l_buf,10));
		strcat(l_CharIDs,";");
	}
	m_tblaccounts->UpdateRow(ply->m_acctid,l_CharIDs);
	l_lockDB.unlock();
	LogLine l_line(g_LogGrpServer);
	/*
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]新建了角色["
		<<l_chaname<<"]，\t当前登录/游戏玩家数:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
	*/
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]create char ["
		<<l_chaname<<"]，\t online/total:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
	l_lockCha.unlock();
	return l_retpk;
}

WPacket	GroupServerApp::TP_DELCHA(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha >=0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);					//应该日值的系统不一致错误
	}else
	{
		uShort	l_len, l_len2;
		cChar	*	l_cha	=pk.ReadString(&l_len);
		cChar   *   l_pw2   =pk.ReadString(&l_len2);
		if(!l_cha ||l_len >16)
		{
			l_retpk.WriteShort(ERR_PT_INERR);
		}
		else if( strcmp( l_pw2, ply->m_password.c_str() ) != 0 )
		{
			l_retpk.WriteShort(ERR_PT_INVALID_PW2);
		}
		else
		{
			MutexArmor l_lockCha(ply->m_mtxCha);
			char	l_chaidx	=ply->FindIndexByChaName(l_cha);
			if(l_chaidx <0)				//本帐号没有这个角色
			{
				l_retpk.WriteShort(ERR_PT_INVALIDCHA);
			}else if(FindGuildByLeadID(ply->m_chaid[l_chaidx]))						//合法的角色
			{
				l_retpk.WriteShort(ERR_PT_ISGLDLEADER);
			}else
			{
				bool bFlag = false;
				int		l_chaid	=ply->m_chaid[l_chaidx];
				char	l_CharIDs[80];l_CharIDs[0]=0;
				char	l_buf[20];
				for(char i=0;i<ply->m_chanum;i++)
				{
					if( i == l_chaidx ) continue;
					strcat(l_CharIDs,itoa(ply->m_chaid[i],l_buf,10));
					strcat(l_CharIDs,";");
				}
				
				MutexArmor l_lockDB(m_mtxDB);
				// 判断角色是否公会成员，否则删除公会列表信息
				if( m_tblaccounts->begin_tran() )
				{
					if( !m_tblaccounts->UpdateRow(ply->m_acctid,l_CharIDs) || !m_tblcharaters->BackupRow(l_chaid) || !m_tblaccounts->commit_tran() )
					{
						m_tblaccounts->rollback();
					}
					else
					{
						bFlag = true;
					}
				}
				l_lockDB.unlock();

				if( bFlag )
				{
					l_retpk.WriteShort(ERR_SUCCESS);	//删除角色成功返回
					ply->m_chanum	--;
					for(;l_chaidx<ply->m_chanum;l_chaidx++)
					{
						ply->m_chaid[l_chaidx]		=ply->m_chaid[l_chaidx+1];
						ply->m_chaname[l_chaidx]	=ply->m_chaname[l_chaidx+1];
						ply->m_motto[l_chaidx]		=ply->m_motto[l_chaidx+1];
						ply->m_icon[l_chaidx]		=ply->m_icon[l_chaidx+1];
						ply->m_guild[l_chaidx]		=ply->m_guild[l_chaidx+1];
					}

					LogLine l_line(g_LogGrpServer);
					/*
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]删除了角色["
						<<l_cha<<"]，\t当前登录/游戏玩家数:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
                   */
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00043)
						<<l_cha<<RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00044)<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
				}
				else
				{
					l_retpk.WriteShort(ERR_PT_SERVERBUSY);	//服务器忙碌，请稍后
					LogLine l_line(g_LogGrpServer);
					/*
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]删除角色失败["
						<<l_cha<<"]，\t当前登录/游戏玩家数:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
					*/
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]delete char failed["
						<<l_cha<<"]，\t GetTotal/m_curChaNum:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
				}
			}
			l_lockCha.unlock();
		}
	}
	return l_retpk;
}

WPacket	GroupServerApp::TP_CREATE_PASSWORD2(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	std::string strPassword = pk.ReadString();
	if( ply->m_password.length() == 0 && strPassword.length() <= ROLE_MAXSIZE_PASSWORD2 )
	{
		if( m_tblaccounts->UpdatePassword( ply->m_acctid, strPassword.c_str() ) )
		{
			ply->m_password = strPassword;
			l_retpk.WriteShort( ERR_SUCCESS );
			LogLine l_line(g_LogErrServer);
			//l_line<<newln<<"帐户:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"数据库操作成功:("<<strPassword.c_str()<<")"<<endln;		
			l_line<<newln<<"account:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"database operate success:("<<strPassword.c_str()<<")"<<endln;		
		}
		else
		{
			l_retpk.WriteShort( ERR_PT_SERVERBUSY );
			LogLine l_line(g_LogErrServer);
			//l_line<<newln<<"帐户:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"数据库操作错误:("<<strPassword.c_str()<<")"<<endln;
			l_line<<newln<<"account:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"database operate failed:("<<strPassword.c_str()<<")"<<endln;
		}
	}
	else
	{
		l_retpk.WriteShort( ERR_PT_INVALID_PW2 );
		LogLine l_line(g_LogErrServer);
		//l_line<<newln<<"帐户:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"错误的二次密码:("<<strPassword.c_str()<<")"<<endln;		
		l_line<<newln<<"account:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"wrong second password:("<<strPassword.c_str()<<")"<<endln;		
	}
	return l_retpk;
}

WPacket GroupServerApp::TP_UPDATE_PASSWORD2(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	std::string strOld = pk.ReadString();
	std::string strPassword = pk.ReadString();	
	if( ply->m_password == strOld && strPassword.length() <= ROLE_MAXSIZE_PASSWORD2 )
	{
		if( m_tblaccounts->UpdatePassword( ply->m_acctid, strPassword.c_str() ) )
		{
			ply->m_password = strPassword;
			l_retpk.WriteShort( ERR_SUCCESS );
		}
		else
		{
			l_retpk.WriteShort( ERR_PT_SERVERBUSY );
		}
	}
	else
	{
		l_retpk.WriteShort( ERR_PT_INVALID_PW2 );
	}
	return l_retpk;
}

/*						char *l_str	=strstr(l_look,";");
						if(l_str)	*l_str=0;
						look.sTypeID	=atoi(l_look);
						l_look	=l_str+1;
						l_str	=strstr(l_look,";");
						for(int i=0;(l_str ||*l_look)&&(i<enumEQUIP_NUM);i++)
						{
							if(l_str)	*l_str=0;
							look.chState[i]	=atoi(l_look);
							if(l_str)
							{
								l_look	=l_str+1;
								l_str	=strstr(l_look,";");
							}else
							{
								l_look --;
							}
						}
						for(int i=0;(l_str ||*l_look)&&(i<enumEQUIP_NUM);i++)
						{
							if(l_str)	*l_str=0;
							look.sLink[i]	=atoi(l_look);
							if(l_str)
							{
								l_look	=l_str+1;
								l_str	=strstr(l_look,";");
							}else
							{
								l_look --;
							}
						}
*/
/*							char	l_tmpbuf[20];
							strcpy(l_look,itoa(look->sTypeID,l_tmpbuf,10));
							for(short i=0;i<enumEQUIP_NUM;i++)
							{
								strcat(l_look,";");
								strcat(l_look,itoa(look->chState[i],l_tmpbuf,10));
							}
							for(short i=0;i<enumEQUIP_NUM;i++)
							{
								strcat(l_look,";");
								strcat(l_look,itoa(look->sLink[i],l_tmpbuf,10));
							}
*/


void GroupServerApp::MP_GARNER2_UPDATE(Player *ply,DataSocket *datasock,RPacket &pk)
{
	ORDERINFO orderinfo;
	//SYSTEMTIME st;time_t
	//GetLocalTime( &st);
	//time_t tt;
	//time(&tt);
	orderinfo .nid = pk.ReadLong();
	string strChaName = pk.ReadString();
	orderinfo.nlev = pk.ReadLong();
	string strjob = pk.ReadString();
	short sFightpoint = pk.ReadShort();

	if(strChaName.length() > 20)
	{
		LogLine	l_line(g_LogGarner2);
		//l_line<<newln<<"反斗白银排名数据出错";
		l_line<<newln<<"order data exception";
		return;
	}
	strcpy(orderinfo.strname,strChaName.c_str());

	if(strjob.length() > 100)
	{
		LogLine	l_line(g_LogGarner2);
		//l_line<<newln<<"反斗白银排名数据出错";
		l_line<<newln<<"order data exception";
		return;
	}
	strcpy(orderinfo.strjob,strjob.c_str());
	orderinfo.nfightpoint = (long)sFightpoint; 
	m_tbLparam->UpdateOrder(orderinfo);
	CP_GARNER2_GETORDER(ply,datasock,pk);
}

void GroupServerApp::CP_GARNER2_GETORDER(Player *ply,DataSocket *datasock,RPacket &pk)
{
		WPacket l_wpk = g_gpsvr->GetWPacket();
		ORDERINFO * porder;
		l_wpk.WriteCmd(CMD_PC_GARNER2_ORDER);
		for(int i = 0;i<MAXORDERNUM;i++)
		{
			porder = m_tbLparam->GetOrderData(i);
			l_wpk.WriteString(porder->strname);
			l_wpk.WriteLong(porder->nlev);
			l_wpk.WriteString(porder->strjob);
			l_wpk.WriteLong(porder->nfightpoint);
		}
		g_gpsvr->SendToClient(ply,l_wpk);
	
}

//Add by sunny.sun 20090828
void GroupServerApp::MP_GM_BANACCOUNT(Player *ply, DataSocket *datasock,RPacket &pk)
{
	string actName = pk.ReadString();
	WPacket l_wpk = g_gpsvr->GetWPacket();
	l_wpk.WriteCmd(CMD_PA_GMBANACCOUNT);
	l_wpk.WriteString(actName.c_str());
	g_gpsvr->SendData(g_gpsvr->m_acctsock,l_wpk);
}

void GroupServerApp::MP_GM_UNBANACCOUNT(Player *ply, DataSocket *datasock,RPacket &pk)
{
	string actName = pk.ReadString();
	WPacket l_wpk = g_gpsvr->GetWPacket();
	l_wpk.WriteCmd(CMD_PA_GMUNBANACCOUNT);
	l_wpk.WriteString(actName.c_str());
	g_gpsvr->SendData(g_gpsvr->m_acctsock,l_wpk);
}